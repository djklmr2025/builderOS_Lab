ORIGINAL FILE: ARK-AI-OS/arkaios_engine.js
--- BEGIN CONTENT ---

// =============================================
// ARKAIOS ENGINE v1.2
// Motor Lógico Centralizado
// CEO IA: ARKAIOS
// =============================================

// Esta es una IIFE (Immediately Invoked Function Expression) para crear un módulo autocontenido.
const ARKAIOS_ENGINE = (() => {
  // --- CONFIGURACIÓN CENTRAL ---
  const FIXED_ENCRYPTION_KEY = "ARKAIOS_SECURE_KEY_2023!@#";
  const CODES_DB_PATH = "codes.json";

  // --- ESTADO EN MEMORIA ---
  let codeDatabase = { available: {}, used: {} };
  let isCodesDbLoaded = false;

  // =============================================
  // SECCIÓN: NÚCLEO DE CIFRADO (DE ejecutor.html)
  // =============================================

  /**
   * Cifra un objeto de datos.
   * @param {object} data - El objeto a cifrar.
   * @returns {string} - Los datos cifrados como una cadena de texto.
   */
  function encryptData(data) {
    const jsonData = JSON.stringify(data);
    return CryptoJS.AES.encrypt(jsonData, FIXED_ENCRYPTION_KEY).toString();
  }

  /**
   * Descifra una cadena de texto a un objeto.
   * Maneja retrocompatibilidad con JSON sin cifrar.
   * @param {string} encryptedData - La cadena cifrada.
   * @returns {object|null} - El objeto descifrado o null si hay error.
   */
  function decryptData(encryptedData) {
    try {
      // Soporte para archivos antiguos no cifrados
      if (encryptedData.trim().startsWith('{')) {
        return JSON.parse(encryptedData);
      }
      const decryptedBytes = CryptoJS.AES.decrypt(encryptedData, FIXED_ENCRYPTION_KEY);
      const decrypted = decryptedBytes.toString(CryptoJS.enc.Utf8);
      if (!decrypted) {
        throw new Error('Archivo corrupto o clave incorrecta.');
      }
      return JSON.parse(decrypted);
    } catch (error) {
      console.error("Error de descifrado:", error);
      throw new Error('Descifrado fallido: ' + error.message);
    }
  }

  // =============================================
  // SECCIÓN: API DEL SISTEMA DE ARCHIVOS (Abstracción para IA)
  // =============================================
  
  // Estas funciones se definen fuera del motor, ya que dependen
  // de las herramientas del entorno de la IA (default_api).
  // Se pasarán como dependencias al inicializar el motor.
  let _fs_read;
  let _fs_write;

  function init(dependencies) {
      _fs_read = dependencies.read;
      _fs_write = dependencies.write;
  }

  // =============================================
  // SECCIÓN: GESTIÓN DE CUENTAS (DE ejecutor.html)
  // =============================================
  
  function generateCardNumber() {
    let num = '';
    for (let i = 0; i < 16; i++) {
      num += Math.floor(Math.random() * 10);
    }
    return num; // Sin espacios
  }

  /**
   * Crea un objeto de cuenta nuevo, listo para ser guardado.
   * @param {string} nombre - Nombre completo del titular.
   * @param {string} usuario - Alias del usuario.
   * @param {number} saldoInicial - Saldo con el que se crea la cuenta.
   * @param {string} createdBy - Quién creó la cuenta (ej. 'ARKADMIN' o 'IA').
   * @returns {object} - El nuevo objeto de cuenta.
   */
  function createAccount(nombre, usuario, saldoInicial, createdBy = 'IA') {
    if (!nombre || !usuario) {
      throw new Error('Nombre y usuario son obligatorios para crear una cuenta.');
    }
    const newAccount = {
      id: `ARK-${Date.now().toString().slice(-6)}`,
      nombre,
      usuario,
      saldo: parseFloat(saldoInicial) || 0,
      tarjeta: generateCardNumber(),
      historial: [`Cuenta creada: ${new Date().toLocaleString()}`],
      movimientos: [],
      metadata: {
        created: new Date().toISOString(),
        createdBy: createdBy
      }
    };
    return newAccount;
  }

  /**
   * Carga y descifra una cuenta desde el sistema de archivos.
   * @param {string} path - Ruta al archivo .arkaios.
   * @returns {Promise<object>} - El objeto de la cuenta.
   */
  async function loadAccount(path) {
    if (!_fs_read) throw new Error("Motor no inicializado. Llama a init() con las dependencias.");
    const response = await _fs_read(path);
    if (response.status !== 'succeeded') {
        throw new Error(`No se pudo leer el archivo de cuenta: ${path}`);
    }
    const encryptedData = response.read_file_response.result;
    return decryptData(encryptedData);
  }

  /**
   * Cifra y guarda un objeto de cuenta en el sistema de archivos.
   * @param {object} accountData - El objeto de cuenta a guardar.
   * @param {string} path - Ruta donde se guardará el archivo .arkaios.
   * @returns {Promise<object>} - Respuesta de la API de escritura.
   */
  async function saveAccount(accountData, path) {
    if (!_fs_write) throw new Error("Motor no inicializado. Llama a init() con las dependencias.");
    const encryptedData = encryptData(accountData);
    return await _fs_write(path, encryptedData);
  }
  
  // =============================================
  // SECCIÓN: TRANSFERENCIAS (DE ejecutor.html y Transferencias.html)
  // =============================================

  /**
   * Realiza una transferencia segura entre dos archivos de cuenta.
   * @param {string} origenPath - Ruta al archivo .arkaios de origen.
   * @param {string} destinoPath - Ruta al archivo .arkaios de destino.
   * @param {number} monto - Cantidad a transferir.
   * @returns {Promise<string>} - El ID de la transacción.
   */
  async function transferir(origenPath, destinoPath, monto) {
    if (monto <= 0) throw new Error("El monto debe ser un número positivo.");

    // Cargar ambas cuentas en paralelo
    const [origen, destino] = await Promise.all([
      loadAccount(origenPath),
      loadAccount(destinoPath)
    ]);

    if (!origen) throw new Error(`Cuenta origen no encontrada o corrupta en ${origenPath}`);
    if (!destino) throw new Error(`Cuenta destino no encontrada o corrupta en ${destinoPath}`);
    if (origen.saldo < monto) throw new Error(`Saldo insuficiente en la cuenta de origen (ID: ${origen.id}).`);

    // Realizar la transacción
    origen.saldo -= monto;
    destino.saldo += monto;
    
    const txId = `TX-${Date.now().toString().slice(-6)}`;
    const now = new Date();
    const movimiento = {
      id: txId,
      fecha: now.toISOString(),
      monto,
      origen: origen.id,
      destino: destino.id,
      estado: "completado"
    };
    
    // Actualizar historiales
    origen.movimientos = origen.movimientos || [];
    destino.movimientos = destino.movimientos || [];
    origen.movimientos.push(movimiento);
    destino.movimientos.push(movimiento);

    origen.historial = origen.historial || [];
    destino.historial = destino.historial || [];
    origen.historial.unshift(`Transferencia enviada: ${monto} a ${destino.id} - ${now.toLocaleString()}`);
    destino.historial.unshift(`Transferencia recibida: ${monto} de ${origen.id} - ${now.toLocaleString()}`);

    // Guardar ambas cuentas en paralelo
    await Promise.all([
      saveAccount(origen, origenPath),
      saveAccount(destino, destinoPath)
    ]);

    return txId;
  }

  // =============================================
  // SECCIÓN: CÓDIGOS DE CANJE (DE cajero.html)
  // =============================================

  function generateRandomString(length) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
  
  async function loadCodes() {
      if(isCodesDbLoaded) return;
      if (!_fs_read) throw new Error("Motor no inicializado. Llama a init() con las dependencias.");
      try {
          const response = await _fs_read(CODES_DB_PATH);
          if (response.status === 'succeeded') {
              codeDatabase = JSON.parse(response.read_file_response.result);
              isCodesDbLoaded = true;
          }
      } catch (e) {
          throw new Error("No se pudo cargar la base de datos de códigos. Puede que no exista todavía.");
      }
  }

  async function saveCodes() {
      if (!_fs_write) throw new Error("Motor no inicializado. Llama a init() con las dependencias.");
      await _fs_write(CODES_DB_PATH, JSON.stringify(codeDatabase, null, 2));
  }
  
  /**
   * Genera nuevos códigos de canje y los guarda en la BD.
   * @param {number} count - Número de códigos a generar.
   * @param {number} value - Valor de cada código.
   * @param {string} expiryDate - Fecha de expiración (YYYY-MM-DD).
   * @returns {Promise<string[]>} - Los nuevos códigos generados.
   */
  async function generateNewCodes(count, value, expiryDate) {
    await loadCodes();
    const newCodes = [];
    for (let i = 0; i < count; i++) {
      const code = 'ARK' + generateRandomString(13).toUpperCase();
      codeDatabase.available[code] = {
        amount: value,
        expires: expiryDate,
        generated: new Date().toISOString()
      };
      newCodes.push(code);
    }
    await saveCodes();
    return newCodes;
  }

  /**
   * Canjea un código, actualizando la cuenta y la BD de códigos.
   * @param {string} accountPath - Ruta al archivo .arkaios de la cuenta.
   * @param {string} code - El código de 16 dígitos a canjear.
   * @returns {Promise<number>} - El monto canjeado.
   */
  async function redeemCode(accountPath, code) {
    code = code.trim().toUpperCase();
    
    await loadCodes();
    
    if (codeDatabase.used[code]) throw new Error("Este código ya ha sido canjeado.");
    if (!codeDatabase.available[code]) throw new Error("Código no reconocido o inválido.");

    const codeInfo = codeDatabase.available[code];
    // Opcional: Validar fecha de expiración
    if (new Date(codeInfo.expires) < new Date()) {
        throw new Error("Este código ha expirado.");
    }
    
    const account = await loadAccount(accountPath);
    if (!account) throw new Error(`La cuenta en ${accountPath} no pudo ser cargada.`);
    
    const amount = codeInfo.amount;

    // Actualizar cuenta
    account.saldo = (account.saldo || 0) + amount;
    account.historial.unshift(`Canje de código ${code}: +${amount} - ${new Date().toLocaleString()}`);
    account.metadata.lastModified = new Date().toISOString();
    
    // Mover código de 'available' a 'used'
    codeDatabase.used[code] = {
      ...codeInfo,
      redeemed: new Date().toISOString(),
      account: account.id
    };
    delete codeDatabase.available[code];

    // Guardar cambios en paralelo
    await Promise.all([
        saveAccount(account, accountPath),
        saveCodes()
    ]);
    
    return amount;
  }

  // =============================================
  // INTERFAZ PÚBLICA DEL MOTOR
  // =============================================
  return {
    init,
    // Funciones de cuentas
    createAccount,
    loadAccount,
    saveAccount,
    // Funciones de operaciones
    transferir,
    redeemCode,
    generateNewCodes,
    // Funciones de bajo nivel (exponer con cuidado)
    encryptData,
    decryptData,
    // Funciones de BD de códigos
    loadCodes,
    saveCodes
  };
})();

--- END CONTENT ---
