ORIGINAL FILE: ARK-AI-OS/routes_pay.py
--- BEGIN CONTENT ---
# routes_pay.py
import os, json, time, hmac, hashlib, base64, uuid
from flask import Blueprint, request, jsonify
from db import get_conn, now_ts

# Stripe (pip install stripe)
import stripe
stripe.api_key = os.getenv("STRIPE_SECRET_KEY", "")

STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET", "")

# Bitso (REST HMAC)
BITSO_API_KEY    = os.getenv("BITSO_API_KEY", "")
BITSO_API_SECRET = os.getenv("BITSO_API_SECRET", "").encode("utf-8")
BITSO_API_BASE   = os.getenv("BITSO_API_BASE", "https://api.bitso.com")  # ajusta si usas sandbox

pay_bp = Blueprint("pay", __name__, url_prefix="/api/pay")


# ------------------ helpers de cuentas (mismo formato que tu app.py) ------------------
def db_account_get(account_id: str):
    conn = get_conn(); cur = conn.cursor()
    cur.execute("SELECT payload_json FROM accounts WHERE account_id=?", (account_id,))
    row = cur.fetchone(); conn.close()
    return json.loads(row[0]) if row else None

def db_account_put(acc_dict: dict):
    conn = get_conn(); cur = conn.cursor()
    cur.execute("""
      INSERT INTO accounts(account_id,payload_json,updated_at)
      VALUES(?,?,?)
      ON CONFLICT(account_id) DO UPDATE SET
        payload_json=excluded.payload_json,
        updated_at=excluded.updated_at
    """, (acc_dict["account_id"], json.dumps(acc_dict, ensure_ascii=False), now_ts()))
    conn.commit(); conn.close()

def ledger_add(account_id: str, type_: str, amount: int, meta: dict):
    conn = get_conn(); cur = conn.cursor()
    cur.execute("INSERT INTO ledger(ts,account_id,type,amount,meta_json) VALUES(?,?,?,?,?)",
                (now_ts(), account_id, type_, int(amount), json.dumps(meta or {})))
    conn.commit(); conn.close()


# ------------------ tabla payments (asegúrate de tenerla en schema.sql) ------------------
def payments_insert(provider, provider_ref, account_id, amount, status="created"):
    conn = get_conn(); cur = conn.cursor()
    cur.execute("""INSERT INTO payments(provider,provider_ref,account_id,amount,status,created_at,updated_at)
                   VALUES(?,?,?,?,?, ?, ?)""",
                (provider, provider_ref, account_id, int(amount), status, now_ts(), now_ts()))
    conn.commit(); conn.close()

def payments_update_status(provider_ref, status, extra=None):
    conn = get_conn(); cur = conn.cursor()
    cur.execute("UPDATE payments SET status=?, updated_at=? WHERE provider_ref=?",
                (status, now_ts(), provider_ref))
    if extra:
        cur.execute("INSERT INTO webhooks(ts,provider,payload_json) VALUES(?,?,?)",
                    (now_ts(), extra.get("provider","unknown"), json.dumps(extra)))
    conn.commit(); conn.close()


# ------------------ Stripe Checkout ------------------
@pay_bp.post("/checkout")
def checkout():
    """
    body: { account_id, amount, provider? = 'stripe'|'bitso' | 'auto', merchant? }
    - stripe => devuelve checkout_url
    - bitso  => devuelve instrucciones (reference/address) o pending_ref
    - auto   => stripe por default
    """
    body = request.json or {}
    account_id = body.get("account_id","").strip()
    amount = int(body.get("amount", 0))
    provider = (body.get("provider") or "stripe").lower()

    if not account_id or amount <= 0:
        return jsonify({"error":"invalid_params"}), 400
    if not db_account_get(account_id):
        return jsonify({"error":"account_not_found"}), 404

    if provider == "bitso":
        # Estrategia: creamos una "orden" interna y damos instrucciones.
        pending_ref = f"BITSO-{uuid.uuid4().hex[:10].upper()}"
        payments_insert("bitso", pending_ref, account_id, amount, "created")
        # Opción A (simple): pedir depósito MXN a tu cuenta Bitso, y tú confirmas por API/panel.
        # Opción B (cripto): generar dirección de depósito (USDT/USDC) y monitorear.
        # Aquí devolvemos instrucciones básicas; ajusta a tu flujo real.
        return jsonify({
            "provider": "bitso",
            "pending_ref": pending_ref,
            "instructions": {
                "message": "Realiza un depósito a tu cuenta Bitso y comparte el comprobante.",
                "note": "Al confirmar el depósito, se acreditará automáticamente a tu cuenta Arkaios.",
                "amount_mxn_hint": amount  # si 1:1; ajusta si manejas tipo de cambio
            }
        })

    # por defecto Stripe
    if not stripe.api_key:
        return jsonify({"error":"stripe_not_configured"}), 500

    # Puedes convertir AEIO-MR->MXN 1:1 o aplicar tu tasa
    amount_mxn = amount  # ajusta según tu pricing real
    session = stripe.checkout.Session.create(
        mode="payment",
        payment_method_types=["card"],
        line_items=[{
            "price_data":{
                "currency":"mxn",
                "product_data":{"name":f"Recarga {amount} AEIO-MR (Arkaios)"},
                "unit_amount": amount_mxn * 100
            },
            "quantity":1
        }],
        success_url=os.getenv("CHECKOUT_SUCCESS_URL", "https://example.com/ok"),
        cancel_url=os.getenv("CHECKOUT_CANCEL_URL", "https://example.com/cancel"),
        metadata={"account_id": account_id, "amount_aeio": str(amount)}
    )
    payments_insert("stripe", session.id, account_id, amount, "created")
    return jsonify({"provider":"stripe", "checkout_url": session.url})


@pay_bp.post("/stripe-webhook")
def stripe_webhook():
    if not STRIPE_WEBHOOK_SECRET:
        return jsonify({"error":"webhook_not_configured"}), 500

    payload = request.data
    sig = request.headers.get("Stripe-Signature")
    try:
        event = stripe.Webhook.construct_event(payload, sig, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return jsonify({"error":"invalid_signature", "detail": str(e)}), 400

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        provider_ref = session["id"]
        account_id = (session.get("metadata") or {}).get("account_id")
        amount_aeio = int((session.get("metadata") or {}).get("amount_aeio","0"))

        acc = db_account_get(account_id)
        if acc and amount_aeio > 0:
            # crédto y ledger
            new_bal = int(acc["balances"].get("AEIO-MR",0)) + amount_aeio
            acc["balances"]["AEIO-MR"] = new_bal
            acc["meta"]["last_modified"] = now_ts()
            acc["nonce"] = str(uuid.uuid4())
            # TODO: recalcular firma acc["sig"] si estás firmando
            db_account_put(acc)
            ledger_add(account_id, "payment", amount_aeio, {"provider":"stripe","session_id":provider_ref})
            payments_update_status(provider_ref, "succeeded", {"provider":"stripe","session":session})

    return "", 200


# ------------------ Bitso: polling/manual confirm ------------------
def bitso_auth_headers(method: str, path: str, body: str = ""):
    # Bitso firma: nonce + method + path + body (sin dominio)
    nonce = str(int(time.time()*1000))
    msg = f"{nonce}{method.upper()}{path}{body}".encode("utf-8")
    sig = hmac.new(BITSO_API_SECRET, msg, hashlib.sha256).hexdigest()
    return {
        "Authorization": f"Bitso {BITSO_API_KEY}:{sig}:{nonce}",
        "Content-Type": "application/json"
    }

@pay_bp.post("/bitso/confirm")
def bitso_confirm_manual():
    """
    body: { pending_ref, account_id, amount }
    - Úsalo si decides confirmar manualmente tras verificar en tu panel o por API.
    """
    body = request.json or {}
    pending_ref = body.get("pending_ref","")
    account_id = body.get("account_id","")
    amount = int(body.get("amount", 0))
    if not (pending_ref and account_id and amount>0):
        return jsonify({"error":"invalid_params"}), 400

    acc = db_account_get(account_id)
    if not acc:
        return jsonify({"error":"account_not_found"}), 404

    # acredita
    new_bal = int(acc["balances"].get("AEIO-MR",0)) + amount
    acc["balances"]["AEIO-MR"] = new_bal
    acc["meta"]["last_modified"] = now_ts()
    acc["nonce"] = str(uuid.uuid4())
    # TODO: recalcular firma si corresponde
    db_account_put(acc)
    ledger_add(account_id, "payment", amount, {"provider":"bitso","pending_ref":pending_ref})
    payments_update_status(pending_ref, "succeeded", {"provider":"bitso","pending_ref":pending_ref})

    return jsonify({"ok": True, "account": acc})


@pay_bp.get("/bitso/poll")
def bitso_poll_example():
    """
    EJEMPLO de polling (ajústalo a tu realidad).
    Idea: consultar /fundings y buscar depósito MXN que coincida con monto/ref.
    """
    if not (BITSO_API_KEY and BITSO_API_SECRET):
        return jsonify({"error":"bitso_not_configured"}), 500

    # Endpoint de ejemplo (ajusta path exacto según documentación oficial)
    # GET /v3/fundings/  (ej: ?limit=20)
    path = "/v3/fundings/"
    url  = f"{BITSO_API_BASE}{path}?limit=20"
    headers = bitso_auth_headers("GET", path, "")
    import urllib.request
    req = urllib.request.Request(url, headers=headers, method="GET")
    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            data = json.loads(resp.read().decode("utf-8"))
    except Exception as e:
        return jsonify({"error":"bitso_request_failed","detail":str(e)}), 502

    return jsonify({"data": data})

--- END CONTENT ---
