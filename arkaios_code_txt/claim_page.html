<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Claim de Token — Página</title>
<style>
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:#0b0f1a;color:#e6eef8;padding:24px}
  .card{background:#071029;border:1px solid #233449;padding:18px;border-radius:12px;max-width:900px;margin:12px auto}
  h1{margin:0 0 8px;font-size:20px}
  label{display:block;margin:8px 0 4px;font-size:13px;color:#9fb3d1}
  input,textarea,select,button{width:100%;padding:10px;border-radius:8px;border:1px solid #233449;background:#021026;color:#e6eef8}
  .row{display:flex;gap:12px}
  .col{flex:1}
  pre{background:#021026;padding:10px;border-radius:8px;overflow:auto;max-height:200px}
  button.primary{background:#3aa1ff;border-color:#3aa1ff;color:#042233;font-weight:700}
  .muted{font-size:13px;color:#9fb3d1}
  .warn{color:#ffcc00}
  .success{color:#7ee787}
</style>
</head>
<body>
  <div class="card">
    <h1>Claim de Token (interfaz segura)</h1>
    <p class="muted">Esta página permite conectar tu wallet (MetaMask u otro proveedor compatible con <code>window.ethereum</code>) y llamar a una función de "claim" / "faucet" de un contrato. <strong>No introduzcas tu clave privada.</strong></p>

    <label>1) Conectar Wallet</label>
    <div class="row" style="align-items:center">
      <div class="col"><button id="btnConnect" class="primary">Conectar MetaMask / Wallet</button></div>
      <div style="width:220px"><span id="account" class="muted">No conectado</span></div>
    </div>

    <hr/>

    <label>2) Dirección del contrato</label>
    <input id="contractAddress" placeholder="0x..." />

    <label>3) Nombre de la función de claim (ej. <code>claim</code>, <code>faucet</code>, <code>claimToken</code>)</label>
    <input id="funcName" value="claim" />

    <label>4) Parámetros (JSON array) — ej. <code>[]</code> o <code>["0xabc...", 1]</code></label>
    <input id="funcArgs" value="[]" />

    <label>5) ABI del contrato (opcional, si no lo pegas se intentará usar un ABI mínimo)</label>
    <textarea id="abi" rows="6" placeholder='[{"constant":false,...}]'></textarea>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="btnCall" class="primary">Llamar función de claim</button>
      <button id="btnEstimate">Estimar gas</button>
    </div>

    <p class="muted">Si no provees ABI, se usará un ABI mínimo que intenta llamar a la función por nombre. Si la llamada falla, pega el ABI completo del contrato (puedes obtenerlo desde un block explorer como WorldScan/Etherscan/Arbiscan).</p>

    <hr/>

    <label>Salida / Logs</label>
    <pre id="log">Listo.</pre>

    <hr/>
    <p class="muted">Advertencia: Ejecutar transacciones consume gas. Asegúrate de confiar en el contrato antes de interactuar. Esta herramienta no firma ni solicita claves; usa tu proveedor web3 (MetaMask) para firmar las transacciones.</p>
  </div>

<script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.min.js"></script>
<script>
const logEl = document.getElementById('log');
const btnConnect = document.getElementById('btnConnect');
const accountEl = document.getElementById('account');
const btnCall = document.getElementById('btnCall');
const btnEstimate = document.getElementById('btnEstimate');

let provider, signer, userAddress;

// util
function log(msg, cls){ logEl.textContent = (new Date().toISOString()) + " — " + msg + "\\n" + logEl.textContent; if(cls==='err'){ logEl.style.color='salmon'; } else if(cls==='ok'){ logEl.style.color='#7ee787'; } }

async function connectWallet(){
  if(window.ethereum === undefined){ alert('No se detectó wallet. Instala MetaMask u otro proveedor.'); return; }
  provider = new ethers.BrowserProvider(window.ethereum);
  try{
    await provider.send('eth_requestAccounts', []);
    signer = await provider.getSigner();
    userAddress = await signer.getAddress();
    accountEl.textContent = userAddress;
    log('Wallet conectada: ' + userAddress, 'ok');
  }catch(e){ log('Conexión cancelada o fallida: ' + (e.message||e), 'err'); }
}

btnConnect.onclick = connectWallet;

// Construir ABI mínimo si no hay
function getAbiOrMinimal(abiText, funcName){
  if(abiText && abiText.trim().length>10){
    try{ return JSON.parse(abiText); }catch(e){ throw new Error('ABI inválido: ' + e.message); }
  }
  return [{
    "inputs": [],
    "name": funcName,
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }];
}

async function getContract(address, abi){
  const network = await provider.getNetwork();
  log('Conectado a red ' + network.name + ' (chainId ' + network.chainId + ')');
  return new ethers.Contract(address, abi, signer);
}

function parseArgs(text){
  if(!text) return [];
  try{ const v = JSON.parse(text); if(!Array.isArray(v)) throw new Error('Los parámetros deben ser un array JSON, ej. [] o ["0x..."]'); return v; }catch(e){ throw new Error('Error parseando parámetros: ' + e.message); }
}

// Botón estimar gas
btnEstimate.onclick = async ()=>{
  try{
    if(!signer){ await connectWallet(); if(!signer) return; }
    const addr = document.getElementById('contractAddress').value.trim();
    if(!addr) throw new Error('Dirección del contrato requerida');
    const abiText = document.getElementById('abi').value.trim();
    const funcName = document.getElementById('funcName').value.trim();
    const args = parseArgs(document.getElementById('funcArgs').value);
    const abi = getAbiOrMinimal(abiText, funcName);
    const contract = await getContract(addr, abi);
    if(typeof contract[funcName] !== 'function'){ log('La función no existe en el ABI proporcionado. Intentaremos una llamada low-level...', 'warn'); }
    const est = await contract.estimateGas[funcName](...args).catch(async (e)=>{
      log('estimateGas falló: ' + (e.message||e), 'warn');
      const populated = await contract.populateTransaction[funcName](...args);
      const res = await provider.estimateGas({...populated, from: userAddress});
      return res;
    });
    log('Estimación gas: ' + est.toString(), 'ok');
  }catch(e){ log('Error: ' + (e.message||e), 'err'); }
};

btnCall.onclick = async ()=>{
  try{
    if(!signer){ await connectWallet(); if(!signer) return; }
    const addr = document.getElementById('contractAddress').value.trim();
    if(!addr) throw new Error('Dirección del contrato requerida');
    const abiText = document.getElementById('abi').value.trim();
    const funcName = document.getElementById('funcName').value.trim();
    const args = parseArgs(document.getElementById('funcArgs').value);
    const abi = getAbiOrMinimal(abiText, funcName);
    const contract = await getContract(addr, abi);

    if(typeof contract[funcName] !== 'function'){
      log('Función no encontrada en ABI. Realizando llamada genérica (popularity: bajo).', 'warn');
      const iface = new ethers.Interface(abi);
      const data = iface.encodeFunctionData(funcName, args);
      const tx = await signer.sendTransaction({ to: addr, data });
      log('Transaction enviada. Hash: ' + tx.hash);
      await tx.wait();
      log('Transacción confirmada: ' + tx.hash, 'ok');
      return;
    }

    const txResponse = await contract[funcName](...args);
    log('Transacción enviada. Hash: ' + txResponse.hash);
    const receipt = await txResponse.wait();
    log('Transacción confirmada en bloque ' + receipt.blockNumber + '. Gas usado: ' + receipt.gasUsed.toString(), 'ok');
  }catch(e){ log('Error al enviar transacción: ' + (e.message||e), 'err'); }
};

log('Interfaz lista. Consejo: pega el ABI si tienes problemas con llamadas. No compartas claves privadas.');
</script>
</body>
</html>
